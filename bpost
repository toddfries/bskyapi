#!/usr/bin/perl

# Copyright (c) 2024 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use LWP::UserAgent;
use JSON qw(encode_json decode_json);
use POSIX qw(strftime);
use Getopt::Std;
use Storable qw(freeze thaw);
use Data::Dumper;

# read/setup tokens

our $access_info;
our $uribase = 'https://bsky.social/xrpc/';

our $opt_a; # action
our $opt_v; # verbose

getopts('a:v');

our $v = 0;
if (defined $opt_v) {
	$v = $opt_v;
}
our $client = { };
$client->{1} = LWP::UserAgent->new(
	timeout => 60,
	max_redirect => 7,
);
$client->{1}->default_header('Atproto-Proxy' => 'did:web:api.bsky.chat#bsky_chat');
$client->{1}->default_header('Content-Type' => 'application/json');

token_check();

if (defined $opt_a) {
	if ($opt_a eq "post") {
		post($ARGV[0]);
		exit(0);
	}
	if ($opt_a eq "lsdm") {
		lsdm();
		exit(0);
	}
	if ($opt_a eq "get") {
		my $c = get1($ARGV[0]);
		if ($c->is_success) {
			my $dc = $c->decoded_content;
			my $data = decode_json($dc);
			print "data = ".Dumper($data);
		} else {
			print "c = ".Dumper($c);
		}
		exit(0);
	}
}

exit(0);

sub lsdm {
	my $call = 'chat.bsky.convo.listConvos';

	_redo_lsdm:
	my $response = get1( $call );
	if (!$response->is_success) {
		my $dc = $response->decoded_content;
		my $data = decode_json($dc);
		if ($data->{error} eq "ExpiredToken") {
			token_refresh();
			goto _redo_lsdm;
		}
	}

	#print Dumper($response);
	if ($response->is_success) {
		print "Requested list was successfully.\n";
	} else {
		print Dumper($response->headers_as_string);
		print Dumper($response->decoded_content);
		die "Failed to post to bsky.app: " . $response->status_line;
	}

	return $response;
}

sub post {
	my ($text) = @_;
	my $call = 'com.atproto.repo.createRecord';

	# Example: Post to bsky.app using the obtained access token
	my $data = {
	repo => $access_info->{handle},
	collection => "app.bsky.feed.post",
	record => {
		"text" => $text,
		"createdAt" => strftime("%Y-%m-%dT%H:%M:%SZ", gmtime),
	},
	};

	my $response = post1( $call, $data );

	print Dumper($response);
	if ($response->is_success) {
		print "Posted to bsky.app successfully.\n";
	} else {
		die "Failed to post to bsky.app: " . $response->status_line;
	}
}

# Function to read authentication information from file
sub read_auth_info {
	my $auth_file = 'auth.txt';
	if (-e $auth_file) {
		open my $fh, '<', $auth_file or die "Can't open $auth_file: $!";
		my $access_info = { };
		chomp($access_info->{handle} = <$fh>);
		chomp($access_info->{refreshJwt} = <$fh>);
		chomp($access_info->{accessJwt} = <$fh>);
		my $tmp = <$fh>;
		if (defined $tmp) {
			chomp($access_info->{last_refresh} = $tmp);
		}
		close $fh;
		return $access_info;
	} else {
		return;
	}
}

# Function to authenticate and get access token
sub authenticate {
	my ($handle, $password) = @_;
	my $req = {
			identifier => $handle,
			password => $password
	};
	my $call = 'com.atproto.server.createSession';
	my $response = _call(1, "post", $call, $req);

	if ($response->is_success) {
		my $auth_info = decode_json($response->decoded_content);
		return $auth_info;
	} else {
		print "Failed to authenticate: " . $response->status_line . "\n";
		die Dumper($response);
	}
}

# Function to save authentication token to file
sub save_auth_info {
	my $access_info = shift;
	print "access_info = ".Dumper($access_info);
	my $auth_file = 'auth.txt';
	open my $fh, '>', $auth_file or die "Cannot open $auth_file: $!";
	printf $fh "%s\n", $access_info->{handle};
	printf $fh "%s\n", $access_info->{refreshJwt};
	printf $fh "%s\n", $access_info->{accessJwt};
	printf $fh "%s\n", time; # save when last refresh occurred
	close $fh;
}


sub token_refresh {
	my $call = 'com.atproto.server.refreshSession';
	$client->{1}->default_header(
		'Authorization' => "Bearer " . $access_info->{refreshJwt}
	);
	my $response = _call(1, "post", $call);

	if ($response->is_success) {
		my $new_auth_info = decode_json($response->decoded_content);
		$access_info->{accessJwt} = $new_auth_info->{accessJwt};
		save_auth_info($access_info);
		$client->{1}->default_header(
			'Authorization' => "Bearer " . $access_info->{accessJwt}
		);
		return $access_info;
	} else {
		print "Failed to refresh token: " . $response->status_line . "\n";
		die Dumper($response);
	}
}

sub token_check {
	if (!defined $access_info) {
		$access_info = read_auth_info();
	}
	my $handle;
	if (!defined $access_info->{handle}) {
		print "Enter your bsky.app handle: (like example.bsky.social) ";
		chomp($handle = <STDIN>);
		$access_info->{handle} = $handle;
	}
	if (!defined $access_info->{accessJwt}) {
		$handle = $access_info->{handle};
		print "Enter your bsky.app password: ";
		chomp(my $password = <STDIN>);
		$access_info = authenticate($handle, $password);
		print Dumper($access_info);
		save_auth_info($access_info);
	}
	$client->{1}->default_header('Authorization' => "Bearer ".$access_info->{accessJwt});

	# Implement logic here, e.g., time check or error handling for expired tokens
	# For a simple time check:
	my $current_time = time;
	my $last_refresh_time = $access_info->{last_refresh} // 0; # Assuming you save this somewhere
	if ($current_time - $last_refresh_time > 7200) {
		$access_info = token_refresh();
	}
}

sub get1 {
	my ($call) = @_;
	token_check();
	return _call(1, "get", $call);
}
sub post1 {
	my ($call, $data) = @_;
	token_check();
	return _call(1, "post", $call, $data);
}

sub _call {
	my ($ver, $type, $query, $pdata) = @_;
	my $name = $query;
	$name =~ s/\?.*$//;
	$name =~ s/\/[0-9]{1,}/\/:id/;
	my ($data, $c);

	my $legit = 0;
	for my $t (("get","post","delete","head")) {
		if ($t eq $type) {
			$legit++;
			last;
		}
	}
	if ($legit < 1) {
		die("_call($ver, '${type}', $query): unhandled type");
	}

	my $savedata = thaw(freeze({ data => $pdata }));
	_redo_action:
	if ($v>0 || 1) {
		printf "v$ver $type query=${query} @ %s\n", strftime( "%Y%m%d %H:%M:%S", localtime());
		if ($type eq "post") {
			print "   payload: ".Dumper($pdata);
		}
	}
	$query = $uribase.$query;
	my $req = HTTP::Request->new(uc($type) => $query);
	my $payload;
	if (defined $pdata) {
		$payload = encode_json($pdata);
		#$payload = $pdata;
		$req = HTTP::Request->new(uc($type) => $query);
		$req->header('Content-Type' => 'application/json');
		$req->content($payload);
	}
	eval {
		$c = $client->{$ver}->request($req);
	};
	$pdata = $savedata->{data};
	if ($v>0 && $type eq "post") {
		print "   pdata after request: ".Dumper($pdata);
	}
	if ($@) {
		die sprintf("get failed: %s", $@);
	}
	if (!defined $c) {
		die("\$c is undef");
	}
	if ($v>0) {
		print "c: ".Dumper($c)."\n";
	}
	print "c = ".Dumper($c);

	return $c;
}

